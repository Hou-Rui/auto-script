#!/usr/bin/env perl
use v5.36;
use threads;
use Env 'HOME', 'PATH';
use POSIX 'floor', 'ceil';
use Getopt::Long;
use Term::ANSIColor;
use File::Basename;
use List::Util 'first';

my (%SRC, %OPT);
my @ALL_SRC = ('native', 'flatpak', 'zsh', 'vim');
my $SUBCMD = shift;

sub which($bin) { first { -e "$_/$bin" } (split ":", $PATH) }
sub first_of($desc, @cmds) {
    first {defined which $_} @cmds or die "error: no $desc found\n";
}

my $AUR_HELPER = first_of "AUR helpers", 'yay', 'paru', 'pacman';
my $SUDO = first_of "sudo utilities", 'sudo', 'doas', 'pkexec';

sub title($fmt, @args) {
    my $str = sprintf $fmt, @args;
    my ($s1, $s2) = map {$_->((80 - length $str) / 2)} (\&ceil, \&floor);
    my $line = sprintf "%s $str %s", '⎼' x $s1, '⎼' x $s2;
    say colored($line, "bold");
}
sub subtitle($fmt, @args) {
    my $str = sprintf $fmt, @args;
    say colored(":: ", "bold blue"), colored($str, "bold");
}

sub pkgs_str           { join ", ", @ARGV }
sub src_str            { join ", ", grep {$SRC{$_}} @ALL_SRC }
sub src_count          { scalar grep {defined $_} values %SRC }

sub die_msg            { die "error in $SUBCMD: @_.\n" }
sub die_no_subcmd      { die "error: missing subcommand.\n" }
sub die_unknown_subcmd { die "error: unknown subcommand '$SUBCMD'.\n" }
sub die_not_applicable { die_msg "source(s)", src_str, "not applicable" }
sub die_not_exclusive  { die_msg "multiple sources", src_str, "specified" }
sub die_no_pkgs        { die_msg "no packages specified" }

sub src_req(%req) {
    if (src_count == 0 and my $defaults = $req{defaults}) {
        $SRC{$_} = 1 for @{$defaults};
    }
    src_count == 1 or die_not_exclusive if $req{exclusive};
    @ARGV or die_no_pkgs if $req{pkgs};
}

sub src_handle(%handlers) {
    for my $src (@ALL_SRC) {
        next if not defined $SRC{$src};
        die_not_applicable if not defined $handlers{$src};
        $handlers{$src}->(@ARGV);
        delete $SRC{$src};
    }
    src_count == 0 or die_not_applicable;
}

sub flag_yes_native  { $OPT{yes} ? ("--noconfirm") : () }
sub flag_yes_flatpak { $OPT{yes} ? ("--assumeyes") : () }

sub subcmd_help($exit_code = 0) {
    say qq {Usage: auto <command> [options] [packages]

Available commands:
  install:    install package(s) (default to native)
  remove:     remove package(s) (default to native)
  search:     search package(s) in remote repositories (default to native and flatpak)
  update:     update package(s) (default to native, flatpak, zsh, vim)
  clean:      clean cache and unused packages (default to native and flatpak)
  info:       display info for a package (default to native)
  which:      query which package owns an executable (default to native)
  list:       list installed packages (default to native and flatpak)
  help:       display this message

Available options:
  -n, --native:     apply operation on native packages
  -f, --flatpak:    apply operation on flatpak packages
  -v, --vim:        apply operation on vim packages
  -z, --zsh:        apply operation on zsh packages
  -y, --yes:        skip all confirmation
  -w, --remote:     (only for info and which) display or query remote info
  -h, --help:       display this message
};
    exit $exit_code;
}

sub subcmd_info(@pkgs) {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        title "Querying information on native package(s) %s...", pkgs_str;
        my $query = $OPT{remote} ? "-Sii" : "-Qii";
        system $AUR_HELPER, $query, @pkgs;
    }, flatpak => sub {
        title "Querying information on flatpak package(s) %s...", pkgs_str;
        my $pat = join " ", @pkgs;
        open my $out, "-|", "flatpak", "list", "--columns=name,application,ref";
        while (<$out>) {
            chomp;
            my ($name, $appid, $ref) = split '\t';
            next if not grep /$pat/i, ($name, $appid);
            subtitle "Information for ref $ref:";
            system "flatpak", "info", $ref;
        }
    }
}

sub subcmd_clean() {
    src_req defaults => ["native", "flatpak"];
    src_handle native => sub {
        title 'Cleaning native packages...';
        subtitle 'Removing unneeded packages...';
        if (my @pkgs = split '\n', `$AUR_HELPER -Qdtq`) {
            system $AUR_HELPER, "-Rscn", @pkgs, flag_yes_native;
        } else {
            say "Nothing unused to uninstall";
        }
        subtitle 'Cleaning cache...';
        system "yes | $AUR_HELPER -Sccd";
    }, flatpak => sub {
        title 'Cleaning flatpak packages...';
        my @flags = ("--unused", "--delete-data", flag_yes_flatpak);
        system "flatpak", "uninstall", @flags;
    }
}

sub parse_flatpak(%req) {
    my ($reversed, $cmd, $pat) = ($req{reversed}, $req{cmd}, $req{pat});
    my $col_remote = defined $pat ? "origin" : "remotes";
    open my $out, "-|", @{$cmd},
        "--columns=name,description,application,version,branch,$col_remote";
    chomp(my @lines = <$out>);
    @lines = reverse @lines if $reversed;
    for (@lines) {
        my ($name, $desc, $appid, $ver, $branch, $remote) = split '\t';
        next if $pat and not grep /$pat/i, ($name, $appid, $desc);
        $remote = colored $remote, "bold blue";
        $appid  = colored $appid, "bold";
        $branch = colored $branch, "bold green";
        $ver    = colored $ver, "cyan";
        say "$remote/$appid $branch $ver";
        say "    $name: $desc";
    }
    close $out;
}

sub subcmd_search(@pkgs) {
    src_req defaults => ["native", "flatpak"], pkgs => 1;
    src_handle native => sub {
        title "Searching native package(s) %s...", pkgs_str;
        system $AUR_HELPER, "-Ss", @pkgs;
    }, flatpak => sub {
        title "Searching Flatpak package(s) %s...", pkgs_str;
        parse_flatpak reversed => 1, cmd => ["flatpak", "search", @pkgs];
    }
}

sub subcmd_install(@pkgs) {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        title "Installing native package(s) %s...", pkgs_str
        system $AUR_HELPER, "-S", @pkgs, flag_yes_native
    }, flatpak => sub {
        title "Installing flatpak package(s) %s...", pkgs_str
        system "flatpak", "install", @pkgs;
    }
}

sub subcmd_remove(@pkgs) {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        title "Removing native package(s) %s...", pkgs_str;
        system $AUR_HELPER, "-Rscn", @pkgs;
    }, flatpak => sub {
        title "Removing Flatpak package(s) %s...", pkgs_str;
        system "flatpak", "uninstall", "--delete-data", @pkgs;
    }
}

sub subcmd_list(@pkgs) {
    src_req defaults => ["native", "flatpak"];
    src_handle native => sub {
        title "Listing native package(s) %s...", pkgs_str;
        system $AUR_HELPER, "-Qs", @pkgs
    }, flatpak => sub {
        title "Listing Flatpak package(s) %s...", pkgs_str;
        my $pat = join " ", @pkgs;
        parse_flatpak cmd => ["flatpak", "list"], pat => $pat;
    }
}

sub subcmd_which(@pkgs) {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        title "Querying which package provides %s...", pkgs_str;
        my @cmd = $OPT{remote} ? ("pkgfile", "-v") : ($AUR_HELPER, "-Qo");
        system @cmd, @pkgs;
    }
}

sub subcmd_update(@pkgs) {
    src_req defaults => \@ALL_SRC;
    src_handle native => sub {
        title "Updating native plugins...";
        my @flags = @pkgs ? ("-S", "--needed", @pkgs) : ("-Syu", "--devel");
        system $AUR_HELPER, @flags, flag_yes_native;
        system $SUDO, "pkgfile", "-u";
    }, flatpak => sub {
        title "Updating Flatpak plugins...";
        system "flatpak", "update", flag_yes_flatpak;
    }, zsh => sub {
        if (-d "$HOME/.zplug") {
            title "Updating ZPlug plugins...";
            system "zsh", "-ic", "zplug update";
        } elsif (-d (my $omz_path = "$HOME/.oh-my-zsh")) {
            title "Updating Oh-My-Zsh plugins...";
            system "zsh", "-c", "$omz_path/tools/upgrade.sh";
            my $custom = "$omz_path/custom";
            for (glob("$custom/plugins/*"), glob("$custom/themes/*")) {
                next unless -d "$_/.git";
                subtitle "Updating plugin %s...", basename $_;
                threads->create(sub { system "cd $_; git pull" });
            }
            $_->join for threads->list;
        }
    }, vim => sub {
        title "Updating Vim plugins...";
        system "nvim", "+Lazy! sync", "+qa", "--headless";
        say "Done."
    }
}

die_no_subcmd if not defined $SUBCMD;
Getopt::Long::Configure "gnu_getopt";
GetOptions (
    "n|native"  => \$SRC{native},
    "f|flatpak" => \$SRC{flatpak},
    "z|zsh"     => \$SRC{zsh},
    "v|vim"     => \$SRC{vim},
    "w|remote"  => \$OPT{remote},
    "y|yes"     => \$OPT{yes},
    "h|help"    => \&subcmd_help
) or die "error: failed to parse options\n";

my $handler = "subcmd_$SUBCMD";
die_unknown_subcmd if not exists &$handler;
(\&$handler)->(@ARGV);
