#!/usr/bin/env perl
use v5.36;
use threads;
use Env 'HOME', 'PATH';
use POSIX 'floor', 'ceil';
use Getopt::Long;
use Term::ANSIColor;
use File::Basename;
use List::Util 'first', 'max';

my (%SRC, %OPT);
my @ALL_SRC = ('native', 'flatpak', 'zsh', 'vim');
my $SUBCMD = shift;

sub pkgs_str           { join ", ", @ARGV }
sub src_str            { join ", ", grep {$SRC{$_}} @ALL_SRC }
sub src_count          { scalar grep {defined $_} values %SRC }

sub die_err            { die "error: @_.\ntype 'auto help' to see usage.\n" }
sub die_err_sub        { die "error in $SUBCMD: @_.\ntype 'auto help' to see usage.\n" }
sub die_no_subcmd      { die_err "missing subcommand" }
sub die_unknown_subcmd { die_err "unknown subcommand '$SUBCMD'" }
sub die_not_applicable { die_err_sub "source(s)", src_str, "not applicable" }
sub die_not_exclusive  { die_err_sub "multiple sources", src_str, "specified" }
sub die_no_pkgs        { die_err_sub "no packages specified" }

sub which($bin) { first { -x "$_/$bin" } (split ":", $PATH) }
sub first_of($desc, @cmds) {
    first {defined which $_} @cmds or die_err "no $desc found";
}

my $AUR_HELPER = first_of "AUR helpers", 'yay', 'paru', 'pacman';
my $SUDO = first_of "sudo utilities", 'sudo', 'doas', 'pkexec';

sub title($fmt, @args) {
    my $str = sprintf $fmt, @args;
    my $len = (80 - length $str) / 2;
    my ($s1, $s2) = map { max 0, $_->($len) } \&ceil, \&floor;
    my $line = sprintf "%s $str %s", '⎼' x $s1, '⎼' x $s2;
    say colored($line, "bold");
}

sub subtitle($fmt, @args) {
    my $str = sprintf $fmt, @args;
    say colored(":: ", "bold blue"), colored($str, "bold");
}

sub src_options {
    map {
        my $short = substr $_, 0, 1;
        "$short|$_" => \$SRC{$_}
    } @ALL_SRC;
}

sub src_req(%req) {
    if (src_count == 0 and my $defaults = $req{defaults}) {
        $SRC{$_} = 1 for @$defaults;
    }
    src_count == 1 or die_not_exclusive if $req{exclusive};
    @ARGV or die_no_pkgs if $req{pkgs};
}

sub src_handle(%handlers) {
    for my $src (@ALL_SRC) {
        next if not defined $SRC{$src};
        die_not_applicable if not defined $handlers{$src};
        $handlers{$src}->(@ARGV);
        delete $SRC{$src};
    }
    src_count == 0 or die_not_applicable;
}

sub flag_yes_native  { $OPT{yes} ? ("--noconfirm") : () }
sub flag_yes_flatpak { $OPT{yes} ? ("--assumeyes") : () }

sub subcmd_help($exit_code = 0) {
    say qq {Usage: auto <command> [options] [packages]

Available commands:
  install:    install package(s) (default to native)
  remove:     remove package(s) (default to native)
  search:     search package(s) in remote repositories (default to native and flatpak)
  update:     update package(s) (default to native, flatpak, zsh, vim)
  clean:      clean cache and unused packages (default to native and flatpak)
  info:       display info for a package (default to native)
  which:      query which package owns an executable (default to native)
  list:       list installed packages (default to native and flatpak)
  help:       display this message

Available options:
  -n, --native:     apply operation on native packages
  -f, --flatpak:    apply operation on flatpak packages
  -v, --vim:        apply operation on vim packages
  -z, --zsh:        apply operation on zsh packages
  -y, --yes:        skip all confirmation
  -w, --remote:     (only for info and which) display or query remote info
  -h, --help:       display this message
};
    exit $exit_code;
}

package FlatpakPkg {
    use List::Util 'any';
    sub new($class, $cols, @args) {
        my $self = {};
        $self->{$_} = shift @args for @$cols;
        bless $self, $class;
    }
    sub match($self, @pkgs) {
        any {
            my ($pkg, @keys) = ($_, 'name', 'application', 'description');
            any { $self->{$_} =~ /$pkg/i } @keys;
        } @pkgs;
    }
}

package FlatpakList {
    use Term::ANSIColor;
    use Scalar::Util 'blessed';
    sub new($class, $cmds, $cols, @pkgs) {
        my $self = [];
        $cols = ['name', 'description', 'application', 'version', 'branch', @$cols];
        my $cols_str = join ',', @$cols;
        open my $out, "-|", "flatpak", @$cmds, "--columns=$cols_str";
        while (<$out>) {
            chomp;
            last if $_ eq "No matches found";
            my $flatpak = FlatpakPkg->new($cols, split '\t');
            next if @pkgs and not $flatpak->match(@pkgs);
            push @$self, $flatpak;
        }
        close $out;
        bless $self, $class;
    }
    sub reversed($self) {
        my @result = reverse @$self;
        bless \@result, blessed($self);
    }
    sub new_list($class, @pkgs) {
        new $class, ['list'], ['origin', 'ref'], @pkgs;
    }
    sub new_search($class, @pkgs) {
        new($class, ['search', @pkgs], ['remotes'])->reversed;
    }
    sub refs($self) { map {$_->{ref}} @$self }
    sub print($self) {
        for my $f (@$self) {
            my $remote_str = $f->{remotes} // $f->{origin};
            my $remote = colored $remote_str, "bold blue";
            my $appid  = colored $f->{application}, "bold";
            my $branch = colored $f->{branch}, "bold green";
            my $ver    = colored $f->{version}, "cyan";
            say "$remote/$appid $branch $ver";
            printf "    %s: %s\n", $f->{name}, $f->{description};
        }
    }
}

sub subcmd_info(@pkgs) {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        title "Querying information on native package(s) %s...", pkgs_str;
        my $query = $OPT{remote} ? "-Sii" : "-Qii";
        system $AUR_HELPER, $query, @pkgs;
    }, flatpak => sub {
        title "Querying information on flatpak package(s) %s...", pkgs_str;
        for my $ref (FlatpakList->new_list(@pkgs)->refs) {
            subtitle "Querying information for $ref...";
            system "flatpak", "info", $ref;
        };
    }
}

sub subcmd_clean() {
    src_req defaults => ["native", "flatpak"];
    src_handle native => sub {
        title 'Cleaning native packages...';
        subtitle 'Removing unneeded packages...';
        if (my @pkgs = split '\n', `$AUR_HELPER -Qdtq`) {
            system $AUR_HELPER, "-Rscn", @pkgs, flag_yes_native;
        } else {
            say "Nothing unused to uninstall";
        }
        subtitle 'Cleaning cache...';
        system "yes | $AUR_HELPER -Sccd";
    }, flatpak => sub {
        title 'Cleaning flatpak packages...';
        my @flags = ("--unused", "--delete-data", flag_yes_flatpak);
        system "flatpak", "uninstall", @flags;
    }
}

sub subcmd_search(@pkgs) {
    src_req defaults => ["native", "flatpak"], pkgs => 1;
    src_handle native => sub {
        title "Searching native package(s) %s...", pkgs_str;
        system $AUR_HELPER, "-Ss", @pkgs;
    }, flatpak => sub {
        title "Searching Flatpak package(s) %s...", pkgs_str;
        FlatpakList->new_search(@pkgs)->print;
    }
}

sub subcmd_install(@pkgs) {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        title "Installing native package(s) %s...", pkgs_str;
        system $AUR_HELPER, "-S", @pkgs, flag_yes_native;
    }, flatpak => sub {
        title "Installing flatpak package(s) %s...", pkgs_str;
        system "flatpak", "install", @pkgs;
    }
}

sub subcmd_remove(@pkgs) {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        title "Removing native package(s) %s...", pkgs_str;
        system $AUR_HELPER, "-Rscn", @pkgs;
    }, flatpak => sub {
        title "Removing Flatpak package(s) %s...", pkgs_str;
        system "flatpak", "uninstall", "--delete-data", @pkgs;
    }
}

sub subcmd_list(@pkgs) {
    src_req defaults => ["native", "flatpak"];
    src_handle native => sub {
        title "Listing native package(s) %s...", pkgs_str;
        system $AUR_HELPER, "-Qs", @pkgs;
    }, flatpak => sub {
        title "Listing Flatpak package(s) %s...", pkgs_str;
        FlatpakList->new_list(@pkgs)->print;
    }
}

sub subcmd_which(@pkgs) {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        title "Querying which package provides %s...", pkgs_str;
        my @cmd = $OPT{remote} ? ("pkgfile", "-v") : ($AUR_HELPER, "-Qo");
        system @cmd, @pkgs;
    }
}

sub subcmd_update(@pkgs) {
    src_req defaults => (@pkgs ? ["native"] : \@ALL_SRC);
    src_handle native => sub {
        title "Updating native plugin(s) %s...", pkgs_str;
        my @flags = @pkgs ? ("-S", "--needed", @pkgs) : ("-Syu", "--devel");
        system $AUR_HELPER, @flags, flag_yes_native;
        system $SUDO, "pkgfile", "-u";
    }, flatpak => sub {
        title "Updating Flatpak plugin(s) %s...", pkgs_str;
        system "flatpak", "update", flag_yes_flatpak, FlatpakList->new_list(@pkgs)->refs;
    }, zsh => sub {
        return if not defined which 'zsh';
        if (-d "$HOME/.zplug") {
            title "Updating ZPlug plugins...";
            system "zsh", "-ic", "zplug update";
        } elsif (-d (my $omz_path = "$HOME/.oh-my-zsh")) {
            title "Updating Oh-My-Zsh plugins...";
            system "zsh", "-c", "$omz_path/tools/upgrade.sh";
            my $custom = "$omz_path/custom";
            for (glob("$custom/plugins/*"), glob("$custom/themes/*")) {
                next unless -d "$_/.git";
                subtitle "Updating plugin %s...", basename $_;
                threads->create(sub { system "cd $_; git pull" });
            }
            $_->join for threads->list;
        }
    }, vim => sub {
        return if not defined which 'nvim';
        title "Updating Vim plugins...";
        system "nvim", "+Lazy! sync", "+qa", "--headless";
        say "Done."
    }
}

die_no_subcmd if not defined $SUBCMD;
subcmd_help if $SUBCMD eq '-h' or $SUBCMD eq '--help';
Getopt::Long::Configure "gnu_getopt";
GetOptions (src_options,
    "w|remote"  => \$OPT{remote},
    "y|yes"     => \$OPT{yes},
    "h|help"    => \&subcmd_help
) or die "error: failed to parse options\n";

my $handler = "subcmd_$SUBCMD";
die_unknown_subcmd if not exists &$handler;
(\&$handler)->(@ARGV);
