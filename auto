#!/usr/bin/env perl
use v5.36;
use Getopt::Long;
use Term::ANSIColor;
use File::Which;
use List::Util 'first', 'none';

my (%SRC, %OPT);
my $AUR_HELPER = first {defined which $_} ('yay', 'paru', 'pacman')
    or die "error: no AUR helper or pacman found.\n";
my @ALL_SRC = ('native', 'flatpak', 'zsh', 'vim');
my $SUBCMD = shift;

sub src_str            { join ", ", grep {$SRC{$_}} @ALL_SRC }
sub die_msg            { die "error in $SUBCMD: @_.\n" }
sub die_no_subcmd      { die "error: missing subcommand.\n" }
sub die_unknown_subcmd { die "error: unknown subcommand '$SUBCMD'.\n" }
sub die_not_applicable { die_msg "source(s)", src_str, "not applicable" }
sub die_not_exclusive  { die_msg "multiple sources", src_str, "specified" }
sub die_no_pkgs        { die_msg "no packages specified" }

sub src_req(%req) {
    my $src_count = grep {defined $_} values %SRC;
    my $defaults = $req{defaults};
    map {$SRC{$_} = 1} @{$defaults} if defined $defaults and $src_count == 0;
    $src_count == 1 or die_not_exclusive if $req{exclusive};
    @ARGV or die_no_pkgs if $req{pkgs};
}

sub src_handle(%handlers) {
    for my $src (@ALL_SRC) {
        next if not defined $SRC{$src};
        die_not_applicable if not defined $handlers{$src};
        $handlers{$src}->(@ARGV);
        delete $SRC{$src};
    }
    none {defined $_} values %SRC or die_not_applicable;
}

sub subcmd_info {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        my $query = $OPT{remote} ? "-Sii" : "-Qii";
        system $AUR_HELPER, $query, @_;
    }, flatpak => sub {
        system "flatpak", "info", @_;
    }
}

sub subcmd_clean {
    src_req defaults => ["native", "flatpak"];
    src_handle native => sub {
        my @pkgs = split '\n', `$AUR_HELPER -Qdtq`;
        my $yes_flag = $OPT{yes} ? "--noconfirm" : "";
        system "$AUR_HELPER -Rscn @pkgs $yes_flag" if @pkgs;
        system "yes | $AUR_HELPER -Sccd";
    }, flatpak => sub {
        my $yes_flag = $OPT{yes} ? "--assumeyes" : "";
        system "flatpak uninstall --unused --delete-data $yes_flag";
    }
}

sub subcmd_search {
    src_req defaults => ["native", "flatpak"], pkgs => 1;
    src_handle native => sub { system $AUR_HELPER, "-Ss", @_},
    flatpak => sub {
        open my $cmd, "-|", "flatpak", "search", @_;
        chomp(my @lines = <$cmd>);
        for (reverse @lines) {
            my ($name, $desc, $appid, $ver, $branch, $remote) = split '\t';
            $remote = colored $remote, "bold blue";
            $appid = colored $appid, "bold";
            $ver = colored $ver, "cyan";
            say "$remote/$appid $ver ($branch)";
            say "    $name: $desc";
        }
        close $cmd;
    }
}

sub subcmd_install {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle
    native  => sub { system $AUR_HELPER, "-Syu", "--needed", @_ },
    flatpak => sub { system "flatpak", "install", @_ }
}

sub subcmd_remove {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle
    native  => sub { system $AUR_HELPER, "-Rscn", @_ },
    flatpak => sub { system "flatpak", "uninstall", "--delete-data", @_ }
}

sub subcmd_which {
    src_req defaults => ["native"], exclusive => 1, pkgs => 1;
    src_handle native => sub {
        my @cmd = $OPT{remote} ? ("pkgfile", "-v") : ($AUR_HELPER, "-Qo");
        system @cmd, @_;
    }
}

die_no_subcmd if not defined $SUBCMD;
Getopt::Long::Configure "gnu_getopt";
GetOptions (
    "n|native" => \$SRC{native},
    "f|flatpak" => \$SRC{flatpak},
    "z|zsh" => \$SRC{zsh},
    "v|vim" => \$SRC{vim},
    "w|remote" => \$OPT{remote},
    "y|yes" => \$OPT{yes},
) or die "failed to parse options\n";

my $handler = "subcmd_$SUBCMD";
die_unknown_subcmd if not exists &$handler;
(\&$handler)->(@ARGV);
